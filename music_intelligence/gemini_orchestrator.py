"""
Gemini Orchestrator - The AI Brain for Music Production

This class integrates Google Gemini 2.5 Flash as the main decision-making AI
for music generation, style analysis, and creative direction.
"""

import os
import asyncio
import logging
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass
from datetime import datetime

import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold

from .style_analyzer import StyleAnalyzer
from .stock_plugin_expert import StockPluginExpert

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class CreativeBrief:
    """Structured creative brief generated by Gemini"""
    style: str
    artist_reference: str
    bpm: int
    key: str
    mood: str
    arrangement_length: float
    track_elements: List[str]
    harmonic_progression: List[str]
    rhythmic_pattern: Dict[str, Any]
    sound_palette: Dict[str, str]
    

class GeminiOrchestrator:
    """
    Main AI orchestrator using Google Gemini 2.5 Flash
    
    This class serves as the creative brain that:
    - Analyzes user requests
    - Makes high-level creative decisions
    - Coordinates between different music generation systems
    - Provides intelligent style guidance
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize the Gemini orchestrator"""
        self.api_key = api_key or os.getenv("GOOGLE_AI_API_KEY")
        if not self.api_key:
            raise ValueError("Google AI API key is required. Set GOOGLE_AI_API_KEY environment variable.")
        
        # Configure Gemini
        genai.configure(api_key=self.api_key)
        
        # Use the latest stable model
        self.model_name = "gemini-2.5-flash-lite"
        
        # Initialize the model with safety settings
        self.model = genai.GenerativeModel(
            model_name=self.model_name,
            generation_config=genai.types.GenerationConfig(
                temperature=0.8,  # Creative but focused
                top_p=0.9,
                top_k=40,
                max_output_tokens=8192,
            ),
            safety_settings={
                HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            }
        )
        
        # Initialize supporting systems
        self.style_analyzer = StyleAnalyzer()
        self.plugin_expert = StockPluginExpert()
        
        # Chat session for multi-turn conversations
        self.chat_session = None
        
        logger.info(f"GeminiOrchestrator initialized with model: {self.model_name}")
    
    async def analyze_user_request(self, user_request: str) -> Dict[str, Any]:
        """
        Analyze user's natural language request and extract musical intent
        
        Args:
            user_request: User's description of what they want to create
            
        Returns:
            Structured analysis of the request
        """
        
        prompt = f"""
        You are an expert music producer and AI assistant. Analyze this user request for music creation:
        
        "{user_request}"
        
        Extract and return the following information in JSON format:
        
        {{
            "style": "primary musical style/genre",
            "artist_reference": "mentioned artist or suggested reference artist",
            "bpm": "suggested BPM (number)",
            "key": "suggested musical key",
            "mood": "emotional mood/energy level",
            "complexity": "simple/intermediate/professional",
            "length_minutes": "suggested track length in minutes",
            "specific_elements": ["list of specific instruments/sounds mentioned"],
            "creative_direction": "overall creative vision summary"
        }}
        
        If any information isn't specified, suggest appropriate defaults based on the style.
        Focus on making this immediately actionable for music production.
        """
        
        try:
            response = await self._generate_content_async(prompt)
            # Extract JSON from response
            import json
            import re
            
            # Find JSON in the response
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                analysis = json.loads(json_match.group())
                logger.info(f"Analyzed user request: {analysis['style']} in {analysis['key']}")
                return analysis
            else:
                raise ValueError("Could not extract JSON from Gemini response")
                
        except Exception as e:
            logger.error(f"Error analyzing user request: {e}")
            # Return safe defaults
            return {
                "style": "house",
                "artist_reference": "generic electronic",
                "bpm": 120,
                "key": "Am",
                "mood": "energetic",
                "complexity": "intermediate",
                "length_minutes": 4.0,
                "specific_elements": [],
                "creative_direction": "Create an engaging electronic track"
            }
    
    async def create_creative_brief(self, analysis: Dict[str, Any]) -> CreativeBrief:
        """
        Create a detailed creative brief based on style analysis
        
        Args:
            analysis: Output from analyze_user_request
            
        Returns:
            Detailed creative brief for track generation
        """
        
        style_characteristics = self.style_analyzer.get_style_characteristics(analysis["style"])
        
        prompt = f"""
        You are a master music producer creating a detailed creative brief. Based on this analysis:
        
        Style: {analysis['style']}
        Artist Reference: {analysis['artist_reference']}
        BPM: {analysis['bpm']}
        Key: {analysis['key']}
        Mood: {analysis['mood']}
        
        And these style characteristics:
        {style_characteristics}
        
        Create a comprehensive creative brief in JSON format:
        
        {{
            "track_elements": ["list of required tracks/instruments"],
            "harmonic_progression": ["chord progression as array"],
            "rhythmic_pattern": {{
                "kick": "kick drum pattern description",
                "snare": "snare pattern description", 
                "hi_hats": "hi-hat pattern description",
                "percussion": "additional percussion description"
            }},
            "sound_palette": {{
                "bass": "bass sound characteristics",
                "leads": "lead sound characteristics",
                "pads": "pad/atmospheric sound characteristics",
                "percussion": "percussion sound characteristics"
            }},
            "arrangement_structure": {{
                "intro": "intro section description and length in bars",
                "verse": "verse section description and length", 
                "chorus": "chorus section description and length",
                "breakdown": "breakdown section description and length",
                "outro": "outro section description and length"
            }},
            "production_notes": "specific production techniques and tips"
        }}
        
        Make this comprehensive and immediately actionable for Ableton Live production.
        """
        
        try:
            response = await self._generate_content_async(prompt)
            import json
            import re
            
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                brief_data = json.loads(json_match.group())
                
                # Create CreativeBrief object
                brief = CreativeBrief(
                    style=analysis["style"],
                    artist_reference=analysis["artist_reference"],
                    bpm=analysis["bpm"],
                    key=analysis["key"],
                    mood=analysis["mood"],
                    arrangement_length=analysis["length_minutes"],
                    track_elements=brief_data.get("track_elements", []),
                    harmonic_progression=brief_data.get("harmonic_progression", []),
                    rhythmic_pattern=brief_data.get("rhythmic_pattern", {}),
                    sound_palette=brief_data.get("sound_palette", {})
                )
                
                logger.info(f"Created creative brief for {brief.style} track")
                return brief
                
        except Exception as e:
            logger.error(f"Error creating creative brief: {e}")
            
        # Return default brief
        return CreativeBrief(
            style=analysis["style"],
            artist_reference=analysis["artist_reference"],
            bpm=analysis["bpm"],
            key=analysis["key"],
            mood=analysis["mood"],
            arrangement_length=analysis["length_minutes"],
            track_elements=["kick", "bass", "lead", "pad"],
            harmonic_progression=["Am", "F", "C", "G"],
            rhythmic_pattern={
                "kick": "four-on-floor",
                "snare": "on beats 2 and 4",
                "hi_hats": "eighth notes",
                "percussion": "minimal"
            },
            sound_palette={
                "bass": "warm and punchy",
                "leads": "bright and cutting",
                "pads": "atmospheric",
                "percussion": "crisp"
            }
        )
    
    async def generate_arrangement_plan(self, brief: CreativeBrief) -> Dict[str, Any]:
        """
        Generate a detailed arrangement plan for the track
        
        Args:
            brief: Creative brief with track details
            
        Returns:
            Detailed arrangement plan with timing and elements
        """
        
        prompt = f"""
        You are an expert music arranger. Create a detailed arrangement plan for a {brief.style} track.
        
        Track Details:
        - Style: {brief.style}
        - BPM: {brief.bpm}
        - Key: {brief.key}
        - Length: {brief.arrangement_length} minutes
        - Elements: {brief.track_elements}
        
        Create a bar-by-bar arrangement plan in JSON format:
        
        {{
            "total_bars": "total number of bars",
            "sections": [
                {{
                    "name": "section name (intro/verse/chorus/etc)",
                    "start_bar": "starting bar number",
                    "end_bar": "ending bar number", 
                    "active_elements": ["which track elements are playing"],
                    "energy_level": "1-10 energy scale",
                    "description": "what happens in this section"
                }}
            ],
            "arrangement_notes": "overall arrangement strategy and tips"
        }}
        
        Make this suitable for {brief.artist_reference} style production.
        Ensure smooth transitions and proper energy flow.
        """
        
        try:
            response = await self._generate_content_async(prompt)
            import json
            import re
            
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                arrangement = json.loads(json_match.group())
                logger.info(f"Generated arrangement plan with {len(arrangement.get('sections', []))} sections")
                return arrangement
                
        except Exception as e:
            logger.error(f"Error generating arrangement plan: {e}")
            
        # Return basic arrangement
        total_bars = int(brief.bpm * brief.arrangement_length / 60 * 4)  # Rough calculation
        return {
            "total_bars": total_bars,
            "sections": [
                {"name": "intro", "start_bar": 1, "end_bar": 16, "active_elements": ["kick", "hi_hats"], "energy_level": 3},
                {"name": "verse", "start_bar": 17, "end_bar": 48, "active_elements": ["kick", "bass", "hi_hats"], "energy_level": 5},
                {"name": "chorus", "start_bar": 49, "end_bar": 80, "active_elements": brief.track_elements, "energy_level": 8},
                {"name": "outro", "start_bar": 81, "end_bar": total_bars, "active_elements": ["pad"], "energy_level": 2}
            ],
            "arrangement_notes": f"Standard {brief.style} arrangement with clear energy progression"
        }
    
    async def _generate_content_async(self, prompt: str) -> str:
        """
        Generate content using Gemini with async support
        
        Args:
            prompt: The prompt to send to Gemini
            
        Returns:
            Generated text response
        """
        try:
            # Use asyncio to run the synchronous generate_content in a thread
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None, 
                lambda: self.model.generate_content(prompt)
            )
            return response.text
            
        except Exception as e:
            logger.error(f"Error generating content with Gemini: {e}")
            raise
    
    def start_chat_session(self, system_instruction: str = None) -> None:
        """Start a multi-turn chat session with Gemini"""
        default_instruction = """
        You are an expert AI music producer specializing in creating complete tracks using Ableton Live.
        You understand music theory, production techniques, and can create professional arrangements.
        You work with stock Ableton plugins only to ensure accessibility.
        Always provide specific, actionable guidance for music creation.
        """
        
        instruction = system_instruction or default_instruction
        self.chat_session = self.model.start_chat(history=[])
        
        # Send system instruction as first message
        self.chat_session.send_message(f"SYSTEM: {instruction}")
        logger.info("Started new chat session with Gemini")
    
    async def chat(self, message: str) -> str:
        """
        Send a message in an ongoing chat session
        
        Args:
            message: Message to send
            
        Returns:
            Gemini's response
        """
        if not self.chat_session:
            self.start_chat_session()
            
        try:
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None,
                lambda: self.chat_session.send_message(message)
            )
            return response.text
            
        except Exception as e:
            logger.error(f"Error in chat: {e}")
            return f"Sorry, I encountered an error: {str(e)}" 